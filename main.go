package main

import (
	"flag"
	"fmt"
	"io"
	"io/fs"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/antchfx/xmlquery"
	"github.com/bbredesen/vk-gen/def"
	log "github.com/sirupsen/logrus"
	"github.com/tidwall/gjson"
)

var (
	inFileName, outDirName string
)

func init() {
	flag.StringVar(&inFileName, "inFile", "vk.xml", "Vulkan XML registry file to read")
	flag.StringVar(&outDirName, "outDir", "output", "Directory to write go-vk output to")

	flag.Parse()
}

func main() {
	_, err := os.Stat(outDirName)
	if err != nil {
		if os.IsNotExist(err) {
			log.Debugf("Creating output directory %s", outDirName)
			os.Mkdir(outDirName, 0777|fs.ModeDir)
		} else {
			log.WithError(err).Fatalf("Could not create output directory %s", outDirName)
		}
	}

	f, err := os.Open(inFileName)
	if err != nil {
		log.WithError(err).Fatalf("Could not open input file %s", inFileName)
	}
	defer f.Close()

	xmlDoc, err := xmlquery.Parse(f)
	if err != nil {
		log.WithError(err).Fatalf("Could not parse XML from %s", inFileName)
	}

	// feats := def.BuildVulkanFeatureSetFromXML(doc, "vulkan", "1.0")

	// tcs := make(def.TypeContainerSet)
	// tcs[def.Include] = def.AllIncludeTypesFromXML(doc)

	exceptionsBytes, err := os.ReadFile("exceptions.json")
	if err != nil {
		log.WithError(err).Fatalf("Could not parse json from exceptions.json")
	}
	jsonDoc := gjson.ParseBytes(exceptionsBytes)

	globalTypes := make(def.TypeRegistry)
	globalValues := make(def.ValueRegistry)

	pm := def.ReadPlatformsFromXML(xmlDoc)
	def.ReadPlatformExceptionsFromJSON(jsonDoc, pm)

	for tc := def.CatNone; tc < def.CatMaximum; tc++ {
		xml, json := tc.ReadFns()
		if xml != nil {
			xml(xmlDoc, globalTypes, globalValues)
		}
		if json != nil {
			json(jsonDoc, globalTypes, globalValues)
		}
	}

	feat := def.ReadFeatureSetFromXML(xmlquery.FindOne(xmlDoc, "//feature[@api='TEMPORARY']"))
	feat.Resolve(globalTypes, globalValues)

	// for _, rt := range feat.ResolvedTypes() {
	// 	rt.PrintPublicDeclaration(os.Stdout)
	// }

	// resolvedByCat := feat.ResolvedTypes().FilterByCategory()
	for tc, reg := range feat.FilterTypesByCategory() { //ResolvedTypes().FilterByCategory() {
		fname := reg.Filename()
		plat := reg.Platform()

		_, _ = fname, plat
		printCategory(tc, reg)
	}

	// def.ReadPlatformTypesFromXML(doc, globalRegistry)
	// def.ReadPlatformExceptionsFromJSON(exceptionsResult, globalRegistry)

	// def.ReadIncludeTypesFromXML(doc, globalRegistry)
	// def.ReadIncludeExceptionsFromJSON(exceptionsResult, globalRegistry)

	// def.ReadPrimitiveTypesFromXML(doc, globalRegistry, globalValues)
	// def.ReadPrimitiveExceptionsFromJSON(exceptionsResult, globalRegistry, globalValues)

	// def.ReadBasetypesFromXML(doc, globalRegistry)

	// def.ReadHandleTypesFromXML(doc, globalRegistry)
	// def.ReadHandleTypeExceptionsFromJSON(exceptionsResult, globalRegistry, globalValues)

	// def.ReadEnumTypesFromXML(doc, globalRegistry, globalValues)
	// // Exceptions?

	// def.ReadBitmaskTypesFromXML(doc, globalRegistry, globalValues)
	// // Exceptions?

	// def.ReadStructTypesFromXML(doc, globalRegistry, globalValues)

	// def.ReadCommandTypesFromXML(doc, globalRegistry, globalValues)

	// globalRegistry.ResolveAll()
	// globalValues.ResolveAll(globalRegistry)

	// for pname, platformReg := range globalRegistry.FilterByPlatform() {
	// 	// platformReg.ResolveAll()
	// 	// globalValues.ResolveAll(platformReg)

	// 	var pt *def.PlatformType
	// 	if tmp := platformReg[pname]; tmp != nil {
	// 		pt = tmp.(*def.PlatformType)
	// 	} else {
	// 		pt = &def.PlatformType{}
	// 	}

	// 	// pt.Resolve(platformReg, globalValues)
	// 	printPlatform(pt, platformReg)
	// }

	// tmpXml := xmlquery.FindOne(doc, "//feature[@api='vulkan' and @number='1.0']")

	// tmpFeature := def.NewFeatureBlockFromXML(tmpXml)
	// tmpFeature.Resolve(globalRegistry, globalValues)

	// featureTypes := globalRegistry.FilterByFeature(tmpFeature)
	// for _, t := range featureTypes {
	// 	t.Resolve(globalRegistry, globalValues)
	// }
	// printFeature(tmpFeature, featureTypes)

	// // ext := def.NewExtensionBlockFromXML(xmlquery.FindOne(doc, "//extension[@name='VK_KHR_display_swapchain']"))

	// // ext.Resolve(globalRegistry)

	// // printByCat(def.Include, tcs)
	// // feats.PrintCategory(def.Include, tcs, os.Stdout)
	copyStaticFiles()

	log.Info("Running 'go generate' on output directory")
	cmd := exec.Command("go", "generate", "./"+outDirName)
	cmd.Stderr = os.Stderr
	goGenErr := cmd.Run()
	if goGenErr != nil {
		fmt.Fprintf(os.Stderr, "Failed to generate: %s\n", goGenErr.Error())
	}

}

const fileHeader string = "// Code generated by go-vk from %s at %s. DO NOT EDIT.\npackage vk\n\n"

// func printPlatform(pt *def.Pla, tr def.TypeRegistry) {
// 	if pt.BuildTag() == "!ignore" || len(tr) <= 1 {
// 		return
// 	}
// 	// for range cats {}
// 	printCategory(pt, def.Include, tr)
// }

// func printFeature(ft def.FeatureCollection, tr def.TypeRegistry) {
// 	for cat := def.CatNone; cat < def.CatMaximum; cat++ {
// 		printCategory(&def.PlatformType{}, cat, tr)
// 	}
// }

func printCategory(tc def.TypeCategory, fc def.FeatureCollection) { //} pt *def.PlatformType, cat def.TypeCategory, tr def.TypeRegistry) {
	reg := fc.ResolvedTypes()
	// vals := reg.Val

	if len(reg) == 0 {
		return
	}

	filename := fc.Filename()
	f, _ := os.Create(outDirName + "/" + filename)
	// explict f.Close() below; not defered because the file must be written before goimports is run

	// if pt.BuildTag() != "" {
	// 	fmt.Fprintf(f, "//go:build %s\n", pt.BuildTag())
	// }

	fmt.Fprintf(f, fileHeader, inFileName, time.Now())

	// if len(pt.Imports()) > 0 {
	// 	fmt.Fprintf(f, "import (\n")
	// 	for _, i := range pt.Imports() {
	// 		fmt.Fprintf(f, "\"%s\"", i)
	// 	}
	// 	fmt.Fprintf(f, ")\n")
	// }
	types := make([]def.TypeDefiner, 0, len(reg))
	for _, v := range reg {
		types = append(types, v)
	}

	sort.Sort(def.ByName(types))
	// if cat == def.Enum {
	def.WriteStringerCommands(f, types, tc)
	// }

	printTypes(f, types)

	f.Close()

	log.Info("Running goimports on ", filename)

	cmd := exec.Command("goimports", "-w", outDirName+"/"+filename)
	cmd.Stderr = os.Stderr
	goimpErr := cmd.Run()
	if goimpErr != nil {
		fmt.Fprintf(os.Stderr, "Failed to format %s: %s\n", filename, goimpErr.Error())
	}

}

func printTypes(w io.Writer, types []def.TypeDefiner) {
	globalBuf := &strings.Builder{}
	initBuf := &strings.Builder{}
	contentBuf := &strings.Builder{}

	for i, v := range types {
		if strings.HasPrefix(v.PublicName(), "!") {
			continue
		}

		v.PrintGlobalDeclarations(globalBuf, i)
		v.PrintFileInitContent(initBuf)

		v.PrintPublicDeclaration(contentBuf)
		// v.PrintInternalDeclaration(contentBuf)
	}

	if globalBuf.Len() > 0 {
		fmt.Fprintf(w, "const (\n")
		fmt.Fprint(w, globalBuf.String())
		fmt.Fprintf(w, ")\n\n")
	}

	if initBuf.Len() > 0 {
		fmt.Fprint(w, "func init() {\n")
		fmt.Fprint(w, initBuf.String())
		fmt.Fprint(w, "}\n\n")
	}

	fmt.Fprint(w, contentBuf.String())

}

func copyStaticFiles() {
	log.Info("Copying static files")
	source := "static_include"

	// Naieve solution from https://stackoverflow.com/questions/51779243/copy-a-folder-in-go
	var err error = filepath.Walk(source, func(path string, info os.FileInfo, err error) error {
		var relPath string = strings.Replace(path, source, "", 1)
		if relPath == "" {
			return nil
		}
		if info.IsDir() {
			return os.Mkdir(filepath.Join(outDirName, relPath), 0777)
		} else {
			var data, err1 = ioutil.ReadFile(filepath.Join(source, relPath))
			if err1 != nil {
				return err1
			}
			return ioutil.WriteFile(filepath.Join(outDirName, relPath), data, 0666)
		}
	})

	if err != nil {
		panic(err)
	}

}
