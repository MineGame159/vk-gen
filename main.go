package main

import (
	"flag"
	"fmt"
	"io"
	"io/fs"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/antchfx/xmlquery"
	"github.com/bbredesen/vk-gen/def"
	"github.com/sirupsen/logrus"
	"github.com/tidwall/gjson"
)

var (
	inFileName, outDirName string
)

func init() {
	flag.StringVar(&inFileName, "inFile", "vk.xml", "Vulkan XML registry file to read")
	flag.StringVar(&outDirName, "outDir", "vk", "Directory to write go-vk output to")

	flag.Parse()

	logrus.SetFormatter(&logrus.TextFormatter{ForceColors: true})
}

func main() {

	_, err := os.Stat(outDirName)
	if err != nil {
		if os.IsNotExist(err) {

			if err := os.Mkdir(outDirName, 0777|fs.ModeDir); err != nil {
				logrus.WithField("error", err).
					Fatal("Could not create output directory")
			} else {
				logrus.WithField("directory", outDirName).
					Info("Output directory created")
			}
		}
	}

	f, err := os.Open(inFileName)
	if err != nil {
		logrus.WithField("error", err).
			WithField("filename", inFileName).
			Fatal("Could not open Vulkan registry file", inFileName, err)
	}
	defer f.Close()

	xmlDoc, err := xmlquery.Parse(f)
	if err != nil {
		logrus.WithField("filename", inFileName).
			WithField("error", err).
			Fatal("Could not parse XML from the provided file")
	}

	// feats := def.BuildVulkanFeatureSetFromXML(doc, "vulkan", "1.0")

	// tcs := make(def.TypeContainerSet)
	// tcs[def.Include] = def.AllIncludeTypesFromXML(doc)

	exceptionsBytes, err := os.ReadFile("exceptions.json")
	if err != nil {
		logrus.WithField("error", err).
			Fatal("Could not parse json from exceptions.json")
	}

	jsonDoc := gjson.ParseBytes(exceptionsBytes)
	_ = jsonDoc
	globalTypes := make(def.TypeRegistry)
	globalValues := make(def.ValueRegistry)

	pm := def.ReadPlatformsFromXML(xmlDoc)
	def.ReadPlatformExceptionsFromJSON(jsonDoc, pm)

	for tc := def.CatNone; tc < def.CatMaximum; tc++ {
		xml, json := tc.ReadFns()
		if xml != nil {
			xml(xmlDoc, globalTypes, globalValues)
		}
		if json != nil {
			json(jsonDoc, globalTypes, globalValues)
		}
	}

	// externalTypes := globalTypes.SelectCategory(def.CatExternal)

	set := def.ReadFeatureFromXML(xmlquery.FindOne(xmlDoc, "//feature[@name='VK_VERSION_1_0']"))
	// set.MergeWith(externalTypes)

	// resolve against a feature set
	// set := def.TestingIncludes(globalTypes)
	set.Resolve(globalTypes, globalValues)

	for tc, reg := range set.FilterTypesByCategory() { //ResolvedTypes().FilterByCategory() {
		fname := reg.FilenameFragment()
		plat := reg.Platform()

		_, _ = fname, plat
		printCategory(tc, reg)
	}

	copyStaticFiles()
}

const fileHeader string = "// Code generated by go-vk from %s at %s. DO NOT EDIT.\npackage vk\n\n"

func printCategory(tc def.TypeCategory, fc def.FeatureCollection) { //} pt *def.PlatformType, cat def.TypeCategory, tr def.TypeRegistry) {
	if tc == def.CatInclude {
		return
	}

	reg := fc.ResolvedTypes()
	// vals := reg.Val

	if len(reg) == 0 {
		return
	}

	filename := fc.FilenameFragment() + ".go"
	f, _ := os.Create(outDirName + "/" + filename)
	// explict f.Close() below; not defered because the file must be written before goimports is run

	// if pt.BuildTag() != "" {
	// 	fmt.Fprintf(f, "//go:build %s\n", pt.BuildTag())
	// }

	fmt.Fprintf(f, fileHeader, inFileName, time.Now())

	// if len(pt.Imports()) > 0 {
	// 	fmt.Fprintf(f, "import (\n")
	// 	for _, i := range pt.Imports() {
	// 		fmt.Fprintf(f, "\"%s\"", i)
	// 	}
	// 	fmt.Fprintf(f, ")\n")
	// }
	types := make([]def.TypeDefiner, 0, len(reg))
	for _, v := range reg {
		types = append(types, v)
	}

	sort.Sort(def.ByName(types))
	// if cat == def.Enum {
	def.WriteStringerCommands(f, types, tc)
	// }

	importMap := make(def.ImportMap)
	for _, t := range types {
		t.RegisterImports(importMap)
	}
	if len(importMap) > 0 {
		keys := importMap.SortedKeys()
		fmt.Fprint(f, "import (\n")
		for _, k := range keys {
			fmt.Fprintf(f, "  \"%s\"\n", k)
		}
		fmt.Fprintln(f, ")")
		fmt.Fprintln(f)
	}

	printTypes(f, types)

	f.Close()

	logrus.WithField("file", filename).Info("Running goimports")

	cmd := exec.Command("goimports", "-w", outDirName+"/"+filename)
	e := &strings.Builder{}
	cmd.Stderr = e

	goimpErr := cmd.Run()
	if goimpErr != nil {
		logrus.
			WithField("file", filename).
			WithField("error", goimpErr.Error()).
			WithField("goimports output", e.String()).
			Error("Failed to format source file")
	}

}

func printTypes(w io.Writer, types []def.TypeDefiner) {
	globalBuf := &strings.Builder{}
	initBuf := &strings.Builder{}
	contentBuf := &strings.Builder{}

	for i, v := range types {
		if strings.HasPrefix(v.PublicName(), "!") {
			continue
		}

		v.PrintGlobalDeclarations(globalBuf, i)
		v.PrintFileInitContent(initBuf)

		v.PrintPublicDeclaration(contentBuf)
		v.PrintInternalDeclaration(contentBuf)
	}

	if globalBuf.Len() > 0 {
		fmt.Fprintf(w, "const (\n")
		fmt.Fprint(w, globalBuf.String())
		fmt.Fprintf(w, ")\n\n")
	}

	if initBuf.Len() > 0 {
		fmt.Fprint(w, "func init() {\n")
		fmt.Fprint(w, initBuf.String())
		fmt.Fprint(w, "}\n\n")
	}

	fmt.Fprint(w, contentBuf.String())

}

func copyStaticFiles() {
	logrus.Info("Copying static files")
	source := "static_include"

	// Naieve solution from https://stackoverflow.com/questions/51779243/copy-a-folder-in-go
	var err error = filepath.Walk(source, func(path string, info os.FileInfo, err error) error {
		var relPath string = strings.Replace(path, source, "", 1)
		if relPath == "" {
			return nil
		}
		if info.IsDir() {
			return os.Mkdir(filepath.Join(outDirName, relPath), 0777)
		} else {
			var data, err1 = ioutil.ReadFile(filepath.Join(source, relPath))
			if err1 != nil {
				return err1
			}
			return ioutil.WriteFile(filepath.Join(outDirName, relPath), data, 0666)
		}
	})

	if err != nil {
		panic(err)
	}

}
